# Snapshot report for `src/tests/generators/offers/Offers.spec.ts`

The actual snapshot is saved in `Offers.spec.ts.snap`.

Generated by [AVA](https://avajs.dev).

## parse calculation list

> Snapshot 1

    `␊
    /* eslint-disable */␊
    // THIS FILE WAS GENERATED␊
    // ALL CHANGES WILL BE OVERWRITTEN␊
    ␊
    // ARCHITECTURE START␊
      export type FetchResponse<T> = {␊
        json: T;␊
        status: number;␊
        args: any;␊
        error: any;␊
      };␊
      ␊
      type Configuration = {␊
        jwtKey: string | undefined;␊
        onResponse?: (response: FetchResponse<any>) => void;␊
      };␊
      ␊
      let CONFIG: Configuration = {␊
        jwtKey: undefined,␊
        onResponse: () => {},␊
      };␊
      ␊
      export function configureApiCalls(configuration: Configuration) {␊
        CONFIG = { ...CONFIG, ...configuration };␊
      }␊
      ␊
      async function fetchJson<T>(...args: any): Promise<FetchResponse<T>> {␊
        const errorResponse = (response: Response, args: any) => {␊
          const errorResponse = { status: response.status, json: null as any, args, error: response };␊
          CONFIG.onResponse && CONFIG.onResponse(errorResponse);␊
          return errorResponse;␊
        }␊
    ␊
        const errorStatus = (status: number, args: any) => {␊
          const errorResponse = { status: status, json: null as any, args, error: new Error("Network error", {cause: status}) };␊
          CONFIG.onResponse && CONFIG.onResponse(errorResponse);␊
          return errorResponse;␊
        }␊
    ␊
        try {␊
          const res: Response = await (fetch as any)(...args);␊
          try {␊
            const json = await res.json();␊
           const isSuccess = res.status >= 200 && res.status < 300;␊
            const response = { json: isSuccess ? json : null, status: res.status, args, error: isSuccess ? null : json };␊
            CONFIG.onResponse && CONFIG.onResponse(response);␊
            return response;␊
          }␊
          catch {␊
            return errorResponse(res, args)␊
          }␊
        } catch {␊
          return errorStatus(503, args);␊
        }␊
      }␊
      ␊
      const updateHeaders = (headers: Headers) => {␊
        if (!headers.has("Content-Type")) {␊
          headers.append("Content-Type", "application/json");␊
        }␊
        const token = CONFIG.jwtKey␊
          ? localStorage.getItem(CONFIG.jwtKey as any)␊
          : undefined;␊
        if (!headers.has("Authorization") && token) {␊
          headers.append("Authorization", token);␊
        }␊
      };␊
    ␊
    function apiPost<TResponse, TRequest>(␊
      url: string,␊
      request: TRequest,␊
      headers: Headers␊
    ) {␊
      var raw = JSON.stringify(request);␊
      updateHeaders(headers);␊
      var requestOptions = {␊
        method: "POST",␊
        headers,␊
        body: raw,␊
        redirect: "follow",␊
      };␊
    ␊
      return fetchJson<TResponse>(url, requestOptions as any);␊
    }␊
    ␊
    type ParamsObject = {␊
      [key: string]: any;␊
    };␊
    ␊
    function apiGet<TResponse>(␊
      url: string,␊
      headers: Headers,␊
      paramsObject: ParamsObject = {}␊
    ) {␊
      updateHeaders(headers);␊
      const queryString = Object.entries(paramsObject)␊
        .filter(([_, val]) => val !== undefined && val !== null)␊
        .map(([key, val]) => \`${key}=${val}\`)␊
        .join("&");␊
      const maybeQueryString = queryString.length > 0 ? \`?${queryString}\` : "";␊
      const requestOptions = {␊
        method: "GET",␊
        headers,␊
        redirect: "follow",␊
      };␊
      return fetchJson<TResponse>(\`${url}${maybeQueryString}\`, requestOptions);␊
    }␊
    ␊
    function apiPut<TResponse, TRequest>(␊
      url: string,␊
      request: TRequest,␊
      headers: Headers␊
    ) {␊
      updateHeaders(headers);␊
    ␊
      var raw = JSON.stringify(request);␊
    ␊
      var requestOptions = {␊
        method: "PUT",␊
        headers,␊
        body: raw,␊
        redirect: "follow",␊
      };␊
    ␊
      return fetchJson<TResponse>(url, requestOptions as any);␊
    }␊
    ␊
    function apiDelete<TResponse>(␊
      url: string,␊
      headers: Headers,␊
      paramsObject: ParamsObject = {}␊
    ) {␊
      updateHeaders(headers);␊
      const queryString = Object.entries(paramsObject)␊
        .filter(([_, val]) => val !== undefined && val !== null)␊
        .map(([key, val]) => \`${key}=${val}\`)␊
        .join("&");␊
      const maybeQueryString = queryString.length > 0 ? \`?${queryString}\` : "";␊
    ␊
      var requestOptions = {␊
        method: "DELETE",␊
        headers,␊
        redirect: "follow",␊
      };␊
      return fetchJson<TResponse>(\`${url}${maybeQueryString}\`, requestOptions);␊
    }␊
    ␊
    function apiPatch<TResponse, TRequest>(␊
      url: string,␊
      request: TRequest,␊
      headers: Headers␊
    ) {␊
      updateHeaders(headers);␊
    ␊
      var raw = JSON.stringify(request);␊
    ␊
      var requestOptions = {␊
        method: "PATCH",␊
        headers,␊
        body: raw,␊
        redirect: "follow",␊
      };␊
    ␊
      return fetchJson<TResponse>(url, requestOptions as any);␊
    }␊
    // ARCHITECTURE END␊
    ␊
    export const API_ROUTES = { ␊
    	getCoinbackOffers: "/api/Coinback/offers",␊
    	getTransactionDetailExternalID: "/api/Transaction/detail"␊
    }␊
    ␊
    export type EntityListOfOfferListItemDto = {␊
    	offset: number;␊
    	limit: number;␊
    	totalCount: number;␊
    	items: OfferListItemDto[];␊
    };␊
    ␊
    export type OfferListItemDto = {␊
    	name: string;␊
    	commissionType: CommissionType;␊
    	commissionValue: number;␊
    	commissionCurrencyCode?: string | null;␊
    	logoUrl?: string | null;␊
    	rank: number;␊
    	visibility: OfferVisibility;␊
    	bestLink: string;␊
    };␊
    ␊
    export enum CommissionType {␊
    	Percents = "Percents",␊
    	Fiat = "Fiat"␊
    }␊
    ␊
    export enum OfferVisibility {␊
    	Visible = "Visible",␊
    	Hidden = "Hidden",␊
    	Promoted = "Promoted"␊
    }␊
    ␊
    export type GetTransactionDetailQueryResult = {␊
    	detail?: TransactionDetailDto | null;␊
    };␊
    ␊
    export type TransactionDetailDto = {␊
    	externalID: string;␊
    	cleanPrice: number;␊
    	cleanAmount: number;␊
    	currencyCode?: string | null;␊
    	currencyName: string;␊
    	recipientAddress?: string | null;␊
    	blockchainTransactionID?: string | null;␊
    	fee: number;␊
    	dateChanged: string;␊
    	orderFee?: number | null;␊
    	orderPrice?: number | null;␊
    	orderAskAmount?: number | null;␊
    	orderAskCurrencyCode?: string | null;␊
    	orderBidCurrencyCode?: string | null;␊
    };␊
    ␊
    export enum InstrumentClass {␊
    	Financial = "Financial",␊
    	Stock = "Stock",␊
    	Bond = "Bond",␊
    	Commodity = "Commodity",␊
    	RealEstate = "RealEstate",␊
    	Index = "Index",␊
    	Alternative = "Alternative",␊
    	Mixed = "Mixed",␊
    	Other = "Other"␊
    }␊
    ␊
    const API_URL = "";␊
    ␊
    export const getCoinbackOffers = (instrumentClass?: InstrumentClass, offset?: number, limit?: number, categoryCode?: string | undefined | null, headers = new Headers()): ␊
    	Promise<FetchResponse<EntityListOfOfferListItemDto>> => {␊
    	const queryParams = {␊
    		"instrumentClass": instrumentClass		,␊
    "offset": offset		,␊
    "limit": limit		,␊
    "categoryCode": categoryCode␊
    	}␊
    	return apiGet(\`${API_URL}/api/Coinback/offers\`, headers, queryParams);␊
    }␊
    ␊
    export const getTransactionDetailExternalID = (externalID: string, headers = new Headers()): ␊
    	Promise<FetchResponse<GetTransactionDetailQueryResult>> => {␊
    	return apiGet(\`${API_URL}/api/Transaction/detail/${externalID}\`, headers, {});␊
    }␊
    ␊
    export const API = { ␊
    	getCoinbackOffers,␊
    	getTransactionDetailExternalID␊
    }␊
    ␊
    `

## Angular parse calculation list

> Snapshot 1

    `␊
    /* eslint-disable */␊
    // THIS FILE WAS GENERATED␊
    // ALL CHANGES WILL BE OVERWRITTEN␊
    ␊
    // ARCHITECTURE START␊
    ␊
    import { HttpClient, HttpErrorResponse, HttpResponse } from '@angular/common/http';␊
    import { Inject, Injectable, InjectionToken, Optional } from '@angular/core';␊
    import { Observable, of, throwError } from 'rxjs';␊
    import { catchError, map } from 'rxjs/operators';␊
    ␊
    type ResponseResult<T, U extends number = 0> = {␊
      status: U;␊
      response: U extends 0 ? unknown : T;␊
    };␊
    ␊
    function createQueryUrl<K extends object>(url: string, paramsObject: K) {␊
      const queryString = Object.entries(paramsObject)␊
        .map(([key, val]) => {␊
    			␊
    			if (key && val !== null && val !== undefined) {␊
    				return Array.isArray(val) ␊
    					? val.map((item) => \`${encodeURIComponent(key)}=${encodeURIComponent(item)}\`).join('&') ␊
    					: \`${encodeURIComponent(key)}=${encodeURIComponent(val)}\`;␊
    			}␊
    			return null;␊
    		})␊
    		.filter(p => !!p)␊
        .join("&");␊
    ␊
      const maybeQueryString = queryString.length > 0 ? \`?${queryString}\` : "";␊
      return \`${url}${maybeQueryString}\`;␊
    }␊
    ␊
    function apiGet<T extends ResponseResult<unknown, number>, U extends object = object>(␊
    	httpClient: HttpClient,␊
    	url: string,␊
    	params?: U,␊
    ): Observable<T | never> {␊
    	const queryUrl = !!params ? createQueryUrl<U>(url, params) : url;␊
    	return httpClient␊
    		.get<HttpResponse<T['response']>>(queryUrl, { observe: 'response' })␊
    		.pipe(␊
    			map(␊
    				(r) =>␊
    					({␊
    						status: r.status,␊
    						response: r.body as T['response'],␊
    					} as T),␊
    			),␊
    			catchError((err) => {␊
    				if (err instanceof HttpErrorResponse) {␊
    					return of({ status: err.status, response: err.error }) as Observable<T>;␊
    				}␊
    				return throwError(() => err);␊
    			}),␊
    		);␊
    }␊
    ␊
    function apiGetFile<T extends ResponseResult<unknown, number>, U extends object = object>(␊
    	httpClient: HttpClient,␊
    	url: string,␊
    	params?: U,␊
    ): Observable<T | never> {␊
    	const mapResult = (response: HttpResponse<Blob>) => {␊
    		const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;␊
    		let fileNameMatch = contentDisposition ? /filename\\*=(?:(\\?['"])(.*?)\\1|(?:[^\\s]+'.*?')?([^;\\n]*))/g.exec(contentDisposition) : undefined;␊
    		let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;␊
    		if (fileName) {␊
    			fileName = decodeURIComponent(fileName);␊
    		} else {␊
    			fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;␊
    			fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;␊
    		}␊
    		return { data: response.body, fileName: fileName };␊
    	}␊
    ␊
    	const queryUrl = !!params ? createQueryUrl<U>(url, params) : url;␊
    	return httpClient␊
    		.get(queryUrl, { observe: 'response', responseType: "blob" })␊
    		.pipe(␊
    			map(␊
    				(r) =>␊
    				({␊
    					status: r.status,␊
    					response: mapResult(r),␊
    				} as T),␊
    			),␊
    			catchError((err) => {␊
    				if (err instanceof HttpErrorResponse) {␊
    					return of({ status: err.status, response: err.error }) as Observable<T>;␊
    				}␊
    				return throwError(() => err);␊
    			}),␊
    		);␊
    }␊
    ␊
    function apiPost<T extends ResponseResult<unknown, number>, U = unknown>(␊
    	httpClient: HttpClient,␊
    	url: string,␊
    	body: U,␊
    ): Observable<T | never> {␊
    	return httpClient␊
    		.post<HttpResponse<T['response']>>(url, body, {␊
    			observe: 'response',␊
    		})␊
    		.pipe(␊
    			map(␊
    				(r) =>␊
    					({␊
    						status: r.status,␊
    						response: r.body as T['response'],␊
    					} as T),␊
    			),␊
    			catchError((err) => {␊
    				if (err instanceof HttpErrorResponse) {␊
    					return of({ status: err.status, response: err.error }) as Observable<T>;␊
    				}␊
    				return throwError(() => err);␊
    			}),␊
    		);␊
    }␊
    ␊
    function apiPut<T extends ResponseResult<unknown, number>, U = unknown>(␊
    	httpClient: HttpClient,␊
    	url: string,␊
    	body: U,␊
    ): Observable<T | never> {␊
    	return httpClient␊
    		.put<HttpResponse<T['response']>>(url, body, {␊
    			observe: 'response',␊
    		})␊
    		.pipe(␊
    			map(␊
    				(r) =>␊
    					({␊
    						status: r.status,␊
    						response: r.body as T['response'],␊
    					} as T),␊
    			),␊
    			catchError((err) => {␊
    				if (err instanceof HttpErrorResponse) {␊
    					return of({ status: err.status, response: err.error }) as Observable<T>;␊
    				}␊
    				return throwError(() => err);␊
    			}),␊
    		);␊
    }␊
    ␊
    function apiDelete<T extends ResponseResult<unknown, number>, U extends object = object>(␊
    	httpClient: HttpClient,␊
    	url: string,␊
    	params?: U,␊
    ) {␊
    	const queryUrl = !!params ? createQueryUrl<U>(url, params) : url;␊
    	return httpClient␊
    		.delete<HttpResponse<T['response']>>(queryUrl, { observe: 'response' })␊
    		.pipe(␊
    			map(␊
    				(r) =>␊
    					({␊
    						status: r.status,␊
    						response: r.body as T['response'],␊
    					} as T),␊
    			),␊
    			catchError((err) => {␊
    				if (err instanceof HttpErrorResponse) {␊
    					return of({ status: err.status, response: err.error }) as Observable<T>;␊
    				}␊
    				return throwError(() => err);␊
    			}),␊
    		);␊
    }␊
    ␊
    function apiPatch<T extends ResponseResult<unknown, number>, U = unknown>(␊
    	httpClient: HttpClient,␊
    	url: string,␊
    	body: U,␊
    ): Observable<T | never> {␊
    	return httpClient␊
    		.patch<HttpResponse<T['response']>>(url, body, {␊
    			observe: 'response',␊
    		})␊
    		.pipe(␊
    			map(␊
    				(r) =>␊
    					({␊
    						status: r.status,␊
    						response: r.body as T['response'],␊
    					} as T),␊
    			),␊
    			catchError((err) => {␊
    				if (err instanceof HttpErrorResponse) {␊
    					return of({ status: err.status, response: err.error }) as Observable<T>;␊
    				}␊
    				return throwError(() => err);␊
    			}),␊
    		);␊
    }␊
    ␊
      // ARCHITECTURE END␊
    ␊
    export interface FileResponse {␊
      data: Blob;␊
      fileName?: string;␊
    }␊
      ␊
    export const API_ROUTES = { ␊
    	getCoinbackOffers: "/api/Coinback/offers",␊
    	getTransactionDetailExternalID: "/api/Transaction/detail"␊
    }␊
    ␊
    export type EntityListOfOfferListItemDto = {␊
    	offset: number;␊
    	limit: number;␊
    	totalCount: number;␊
    	items: OfferListItemDto[];␊
    };␊
    ␊
    export type OfferListItemDto = {␊
    	name: string;␊
    	commissionType: CommissionType;␊
    	commissionValue: number;␊
    	commissionCurrencyCode?: string | null;␊
    	logoUrl?: string | null;␊
    	rank: number;␊
    	visibility: OfferVisibility;␊
    	bestLink: string;␊
    };␊
    ␊
    export enum CommissionType {␊
    	Percents = "Percents",␊
    	Fiat = "Fiat"␊
    }␊
    ␊
    export enum OfferVisibility {␊
    	Visible = "Visible",␊
    	Hidden = "Hidden",␊
    	Promoted = "Promoted"␊
    }␊
    ␊
    export type GetTransactionDetailQueryResult = {␊
    	detail?: TransactionDetailDto | null;␊
    };␊
    ␊
    export type TransactionDetailDto = {␊
    	externalID: string;␊
    	cleanPrice: number;␊
    	cleanAmount: number;␊
    	currencyCode?: string | null;␊
    	currencyName: string;␊
    	recipientAddress?: string | null;␊
    	blockchainTransactionID?: string | null;␊
    	fee: number;␊
    	dateChanged: string;␊
    	orderFee?: number | null;␊
    	orderPrice?: number | null;␊
    	orderAskAmount?: number | null;␊
    	orderAskCurrencyCode?: string | null;␊
    	orderBidCurrencyCode?: string | null;␊
    };␊
    ␊
    export enum InstrumentClass {␊
    	Financial = "Financial",␊
    	Stock = "Stock",␊
    	Bond = "Bond",␊
    	Commodity = "Commodity",␊
    	RealEstate = "RealEstate",␊
    	Index = "Index",␊
    	Alternative = "Alternative",␊
    	Mixed = "Mixed",␊
    	Other = "Other"␊
    }␊
    ␊
    ␊
    ␊
    export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');␊
    ␊
    @Injectable()␊
    export class ApiService {␊
      private httpClient: HttpClient;␊
      private baseUrl: string;␊
    ␊
      constructor(␊
        @Inject(HttpClient) httpClient: HttpClient,␊
        @Optional() @Inject(API_BASE_URL) baseUrl?: string␊
      ) {␊
          this.httpClient = httpClient;␊
          this.baseUrl = baseUrl ?? "";␊
      }␊
    ␊
      ␊
    	␊
        getCoinbackOffers(instrumentClass?: InstrumentClass, offset?: number, limit?: number, categoryCode?: string | undefined | null): Observable<ResponseResult<EntityListOfOfferListItemDto, 200>> {␊
          const queryParams = {␊
    		"instrumentClass": instrumentClass		,␊
    "offset": offset		,␊
    "limit": limit		,␊
    "categoryCode": categoryCode␊
    	}␊
    	␊
          return apiGet<ResponseResult<EntityListOfOfferListItemDto, 200>>(this.httpClient, \`${this.baseUrl}/api/Coinback/offers\`, queryParams);␊
        }␊
        ␊
    ␊
        getTransactionDetailExternalID(externalID: string): Observable<ResponseResult<GetTransactionDetailQueryResult, 200>> {␊
          ␊
          return apiGet<ResponseResult<GetTransactionDetailQueryResult, 200>>(this.httpClient, \`${this.baseUrl}/api/Transaction/detail/${externalID}\`);␊
        }␊
        ␊
    ␊
    ␊
    }␊
      ␊
      ␊
    ␊
    `
